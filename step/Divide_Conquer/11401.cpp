/*
Problem: 이항 계수 3(11401)
Tier: Gold 1
Detail: 자연수 N과 정수 K가 주어졌을 때 이항 계수 를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.
Comment: 
## 1. int와 long long의 범위를 생각해봅시다.
C/C++에서 수의 표현은 사실 매우 제한적입니다. 가장 많이 사용하는 정수 자료형인 int와 long long를 봅시다.
- int는 4바이트(32비트)로 -2^31에서 2^31-1만큼 표현할 수 있습니다. 이는 -2147483648 ~ 2147483647입니다. 이는 2e9로 근사할 수 있습니다.
- long long은 8바이트(64비트)로 -2^63에서 2^63만큼 표현할 수 있습니다. 이는 9.22337204e18 ~ +9.22337204e18 입니다. 이는 이미 근사했지만 9e18로 근사할 수 있습니다.
하지만 21!만해도 long long의 범위를 넘어 버립니다. 그렇다면 조합이나 가짓수를 세는 문제에서는 쉽게 오버플로가 되는 것이죠.
그렇다면 매우 큰 결과를 표현하고, 이를 체크하기 위해서는 어떤 방법이 있을까요? 물론 문자열로 수를 표현하여 이를 비교하는 방법도 있겠지만, 이는 문제의 본질을 흐리는 방법입니다.
세터(문제출제자)는 큰 수를 표현하는 방법을 묻고 싶은게 아니니까요. (물론 그런 문제도 종종 있습니다. 그럴 때는 Java의 빅인티저 또는 파이썬을 사용하는 것을 추천합니다)
그렇기에 이를 효율적으로 나타내기 위해 모듈러 연산을 사용하는 것입니다.
## 2. 그러나 왜 굳이 1e9+7일까 : 크기와 암기
하지만 모듈러가 지나치게 작다면 이는 언어의 표현력을 비효율적으로 사용하는 것입니다.
그렇기에 int가 표현할 수 있는 내용을 최대한 활용하기 위해서는 int의 max값에 가까워야 합니다.
그렇기에 약 2e9의 값을 사용할 수도 있습니다. 하지만 덧셈 연산과 뺄셈 연산에서 2e9에 근사하는 값들의 연산을 한다면 어떨까요? 역시 2e9+2e9 = 4e9가 되어 오버플로우가 발생합니다.
뺄셈도 마찬가지입니다. 그렇기에 2^30에 근사하는 값을 가져야 합니다. 이는 1e9에 가까운 값 중에 소수인 1e9+7을 사용하는 것입니다.
이 값은 곱해도 long long의 범위를 넘지 않는다는 장점 또한 가지고 있습니다.
또한 이 수는 모양이 매우 단순하여 암기가 편하다는 장점이 있습니다.
------------
결론: 1e9 + 7 이 나오면 소수 모듈러 연산이라는 걸 생각하고 풀자...

+ (A/B mod c -> (A mod C) * (B mod C) mod c)
*/

#include <stdio.h>

int N, K;
const int mod = 1e9+7;
long long int fac[4000001];

long long int cal(int x, int y) {
    if(y == 0) return 1;
    long long int half = cal(x, y/2);
    long long int tmp = (half * half) % mod;
    if(y % 2 == 1) return (tmp * x) % mod;
    else return tmp;
}

int main() {
    fac[0] = 1;
    scanf("%d %d", &N, &K);
    for(int i = 1; i <= N; i++) {
        fac[i] = (fac[i-1] * i) % mod;
    } 
    printf("%lld", (cal((fac[N-K] * fac[K]) % mod, mod - 2) * fac[N]) % mod);
    return 0;
}