/*
Problem: 타일 코드 (1720)
Tier: Gold 5
Detail: 2×N 크기의 넓은 판을 1×2 (또는 2×1) 크기와 2×2 크기의 타일로 채우려고 한다. 여러 가지 경우가 있을 수 있으므로, 각각을 하나의 코드로 대응시켜서 암호화에 이용하려고 한다.
그런데 문제가 생겼다. 넓은 판을 교환하다 보니 좌우 대칭인 경우가 있어, 뒤집히는 경우 코드가 헷갈리게 되는 경우가 발생한 것이다. 
N이 주어지면, 전체 타일 코드의 개수를 구하는 프로그램을 작성하시오. (단, 서로 좌우 대칭을 이루는 중복된 표현은 한 가지 경우로만 처리한다.)
Comment: 처음부터 모양이 좌우대칭인 경우: 좌우대칭이 발생하지 않음
따라서 점화식을 정리하면...
기본적인 모양의 수: DP[N] = 2*DP[N-2] + DP[N-1]
좌우대칭인 모양의 수: DP_S[N] = DP_S[N-2] + 2DP_S[N-4]
답의 수: DP_R[N] = (DP[N] - DP_S[N]) / 2 + DP_S[N]
*/

#include <stdio.h>

int dp[31], dp_s[31], dp_r[31];
int N;

int main() {
    scanf("%d", &N);
    dp[0] = 1, dp[1] = 1;
    dp_s[0] = 1, dp_s[1] = 1, dp_s[2] = 3, dp_s[3] = 1;
    for (int i = 2; i <= N; i++) dp[i] = 2 * dp[i - 2] + dp[i - 1];
    for (int i = 4; i <= N; i++) dp_s[i] = dp_s[i - 2] + 2 * dp_s[i - 4];
    printf("%d", (dp[N] - dp_s[N]) / 2 + dp_s[N]);
    return 0;   
}