/*
Problem: 백양로 브레이크
Tier: Gold 4
Detail: 서울 소재 Y모 대학교에서 대규모 공사를 진행하면서, 학교가 마치 미로처럼 변해버리고 말았다.
공사 이전까지는 어떤 건물에서 출발하더라도 다른 모든 건물로 갈 수 있는 길이 있었으나, 공사가 진행되면서 어떻게 한 건진 알 수 없지만 일방통행만 가능한 길이 많이 늘고 말았다.
컴퓨터과학과 학생 남규는 전공 수업을 듣고 교양 수업을 들으러 가던 중 길을 잃어 3일 밤낮을 헤매다가 공학관에서 종합관으로 가는 길은 존재하지 않는다는 결론을 내렸다.
3일 사이에 과제도 내지 못하고 출석도 하지 못해 학사경고 위기에 처한 남규는 전공을 살려 현재 일방통행인 길들 중 반드시 양방향으로 바꿔야만 하는 길이 몇 개인지 조사해 학교에 건의하기로 마음을 먹었다.
남규는 여러 건물들 사이를 직접 잇는 길들을 모두 조사했고, 그 중 어떤 길들이 일방통행인지, 또는 양방향 통행이 가능한지를 모두 체크했다.
남규의 프로그램은 간단하다. 출발지와 도착지를 입력하면 도착지까지 가기 위해 최소 몇 개의 길을 양방향으로 바꿔야만 하는지를 출력해준다. 프로그램이 완성되었다는 소문이 퍼지자, 남규처럼 길을 잃고 헤맨 경험이 있는 학생들은 남규에게 묻기 시작했다.
남규는 매번 손으로 타이핑해 입력하고 결과를 보내주는 데에 지치고 말았다. 결국 앓아누운 남규를 위해 학생들의 질문을 해결할 새로운 프로그램을 만들어보자.
Comment: 매우매우 간단한 플로이드-워셜 알고리즘
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int dp[251][251], N, M, K;
const int INF = 100000;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cin >> N >> M;
    for(int i = 1; i <= N; i++) {
        for(int j = 1; j <= N; j++) {
            dp[i][j] = (i == j) ? 0 : INF;
        }
    }
    for(int i = 0; i < M; i++) {
        int x, y, z; cin >> x >> y >> z;
        dp[x][y] = 0;
        if(z) dp[y][x] = 0;
        else dp[y][x] = 1;
}
    for(int k = 1; k <= N; k++)
        for(int i = 1; i <= N; i++)
            for(int j = 1; j <= N; j++)
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
    cin >> K;
    for(int i = 0; i < K; i++) {
        int x, y; cin >> x >> y;
        cout << dp[x][y] << '\n';
    }
}
