언제나 작성할 때는 [참고]를 하자.
# Ch01-02
### 별건 아니고, ~~별 거 맞던데~~ 간단한 레퍼런스와 포인터의 차이를 알아보자.
### 보다보니까 느끼는건데, C의 강의도 번갈아서 볼 수 있으면 좋겠음.
### 올해 끝나기 전 까지는 마무리 했으면 좋겠음 ㅠㅠ...

### Ch01

```c++
#include <iostream>

namespace {
// 이 함수는 이 파일 안에서만 사용할 수 있습니다.
// 이는 마치 static int OnlyInThisFile() 과 동일합니다.
int OnlyInThisFile() {}

// 이 변수 역시 static int x 와 동일합니다.
int only_in_this_file = 0;
}  // namespace

int main() {
  OnlyInThisFile();
  only_in_this_file = 3;
}
```

아 ~~설명 쓰기 싫어...~~  
일단 그냥 보자.

### Ch02

```c++
#include <iostream>

int change_val(int *p) {
  *p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(&number);
  std::cout << number << std::endl;
}
```

결과값이  
> 5  
> 3  

이라는 건 ㅈㄴ 쉽지 뭐..  
근데 아래 코드는 어떨까?  
```c++
#include <iostream>

int change_val(int &p) {
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  std::cout << number << std::endl;
  change_val(number);
  std::cout << number << std::endl;
}
```

놀랍게도 결과는 같다.  
?????  
이런것을 **레퍼런스**라고 하는데, *다른 변수의 참조자*라는 의미로 받아들이면 될 것 같음...
위 경우 `p` 가 `number`의 다른 이름이 된다고 생각하면 됨.  
흠... 너무 어려운데

```c++
int& ref = number;
```

> 하지만 포인터 자체는 '메모리 값을 보관하는 변수' 자체로 활용될 수 있지만 참조자는 그렇지 않습니다. 참조자는 포인터 처럼 어떠한 메모리 공간에 할당되어서 자신을 참조하는 주소값을 보관하는 것이 아닙니다. 컴파일 시에 원래 가리키던 변수의 주소값으로 다 치환되버리죠. (*(주소값) 으로)

라고 하네.

```c++
// 참조자 이해해보기

#include <iostream>

int main() {
  int x;
  int& y = x;
  int& z = y;
  
  x = 1;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
  
  y = 2;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
    
  z = 3;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
  
  return 0;
}
```

근데 생각해보면 조금 이해 가기도 하는데?  
> reference = Alias?  

라고 생각하기로 합시다! ~~또 따지고 보면 틀리겠지만 일단 이렇게 받아들이자는 소리여;;~~  

주저리 주저리 하다보니 깨달은건데
```c++
int& x = y; //x는 y의 reference?
int* x = &y //x는 y의 pointer
```
라고 생각하면 될 것 같음!!!!

[참고]: https://heropy.blog/2017/09/30/markdown/
